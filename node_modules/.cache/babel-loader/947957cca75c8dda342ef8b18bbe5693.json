{"ast":null,"code":"'use strict';\n\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\n\nconst astralRegex = require('astral-regex');\n\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = ['\\u001B', '\\u009B'];\nconst END_CODE = 39;\n\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\n\nmodule.exports = (str, begin, end) => {\n  const arr = [...str.normalize()];\n  end = typeof end === 'number' ? end : arr.length;\n  let insideEscape = false;\n  let escapeCode = null;\n  let visible = 0;\n  let output = '';\n\n  for (const [i, x] of arr.entries()) {\n    let leftEscape = false;\n\n    if (ESCAPES.includes(x)) {\n      insideEscape = true;\n      const code = /\\d[^m]*/.exec(str.slice(i, i + 18));\n      escapeCode = code === END_CODE ? null : code;\n    } else if (insideEscape && x === 'm') {\n      insideEscape = false;\n      leftEscape = true;\n    }\n\n    if (!insideEscape && !leftEscape) {\n      ++visible;\n    }\n\n    if (!astralRegex({\n      exact: true\n    }).test(x) && isFullwidthCodePoint(x.codePointAt())) {\n      ++visible;\n    }\n\n    if (visible > begin && visible <= end) {\n      output += x;\n    } else if (visible === begin && !insideEscape && escapeCode !== null && escapeCode !== END_CODE) {\n      output += wrapAnsi(escapeCode);\n    } else if (visible >= end) {\n      if (escapeCode !== null) {\n        output += wrapAnsi(ansiStyles.codes.get(parseInt(escapeCode, 10)) || END_CODE);\n      }\n\n      break;\n    }\n  }\n\n  return output;\n};","map":{"version":3,"sources":["/home/vickey/Desktop/mine/node_modules/slice-ansi/index.js"],"names":["isFullwidthCodePoint","require","astralRegex","ansiStyles","ESCAPES","END_CODE","wrapAnsi","code","module","exports","str","begin","end","arr","normalize","length","insideEscape","escapeCode","visible","output","i","x","entries","leftEscape","includes","exec","slice","exact","test","codePointAt","codes","get","parseInt"],"mappings":"AAAA;;AACA,MAAMA,oBAAoB,GAAGC,OAAO,CAAC,yBAAD,CAApC;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,aAAD,CAA1B;;AAEA,MAAMG,OAAO,GAAG,CACf,QADe,EAEf,QAFe,CAAhB;AAKA,MAAMC,QAAQ,GAAG,EAAjB;;AAEA,MAAMC,QAAQ,GAAGC,IAAI,IAAK,GAAEH,OAAO,CAAC,CAAD,CAAI,IAAGG,IAAK,GAA/C;;AAEAC,MAAM,CAACC,OAAP,GAAiB,CAACC,GAAD,EAAMC,KAAN,EAAaC,GAAb,KAAqB;AACrC,QAAMC,GAAG,GAAG,CAAC,GAAGH,GAAG,CAACI,SAAJ,EAAJ,CAAZ;AAEAF,EAAAA,GAAG,GAAG,OAAOA,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCC,GAAG,CAACE,MAA1C;AAEA,MAAIC,YAAY,GAAG,KAAnB;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,MAAM,GAAG,EAAb;;AAEA,OAAK,MAAM,CAACC,CAAD,EAAIC,CAAJ,CAAX,IAAqBR,GAAG,CAACS,OAAJ,EAArB,EAAoC;AACnC,QAAIC,UAAU,GAAG,KAAjB;;AAEA,QAAInB,OAAO,CAACoB,QAAR,CAAiBH,CAAjB,CAAJ,EAAyB;AACxBL,MAAAA,YAAY,GAAG,IAAf;AACA,YAAMT,IAAI,GAAG,UAAUkB,IAAV,CAAef,GAAG,CAACgB,KAAJ,CAAUN,CAAV,EAAaA,CAAC,GAAG,EAAjB,CAAf,CAAb;AACAH,MAAAA,UAAU,GAAGV,IAAI,KAAKF,QAAT,GAAoB,IAApB,GAA2BE,IAAxC;AACA,KAJD,MAIO,IAAIS,YAAY,IAAIK,CAAC,KAAK,GAA1B,EAA+B;AACrCL,MAAAA,YAAY,GAAG,KAAf;AACAO,MAAAA,UAAU,GAAG,IAAb;AACA;;AAED,QAAI,CAACP,YAAD,IAAiB,CAACO,UAAtB,EAAkC;AACjC,QAAEL,OAAF;AACA;;AAED,QAAI,CAAChB,WAAW,CAAC;AAACyB,MAAAA,KAAK,EAAE;AAAR,KAAD,CAAX,CAA2BC,IAA3B,CAAgCP,CAAhC,CAAD,IAAuCrB,oBAAoB,CAACqB,CAAC,CAACQ,WAAF,EAAD,CAA/D,EAAkF;AACjF,QAAEX,OAAF;AACA;;AAED,QAAIA,OAAO,GAAGP,KAAV,IAAmBO,OAAO,IAAIN,GAAlC,EAAuC;AACtCO,MAAAA,MAAM,IAAIE,CAAV;AACA,KAFD,MAEO,IAAIH,OAAO,KAAKP,KAAZ,IAAqB,CAACK,YAAtB,IAAsCC,UAAU,KAAK,IAArD,IAA6DA,UAAU,KAAKZ,QAAhF,EAA0F;AAChGc,MAAAA,MAAM,IAAIb,QAAQ,CAACW,UAAD,CAAlB;AACA,KAFM,MAEA,IAAIC,OAAO,IAAIN,GAAf,EAAoB;AAC1B,UAAIK,UAAU,KAAK,IAAnB,EAAyB;AACxBE,QAAAA,MAAM,IAAIb,QAAQ,CAACH,UAAU,CAAC2B,KAAX,CAAiBC,GAAjB,CAAqBC,QAAQ,CAACf,UAAD,EAAa,EAAb,CAA7B,KAAkDZ,QAAnD,CAAlB;AACA;;AAED;AACA;AACD;;AAED,SAAOc,MAAP;AACA,CA5CD","sourcesContent":["'use strict';\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst astralRegex = require('astral-regex');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = [\n\t'\\u001B',\n\t'\\u009B'\n];\n\nconst END_CODE = 39;\n\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\n\nmodule.exports = (str, begin, end) => {\n\tconst arr = [...str.normalize()];\n\n\tend = typeof end === 'number' ? end : arr.length;\n\n\tlet insideEscape = false;\n\tlet escapeCode = null;\n\tlet visible = 0;\n\tlet output = '';\n\n\tfor (const [i, x] of arr.entries()) {\n\t\tlet leftEscape = false;\n\n\t\tif (ESCAPES.includes(x)) {\n\t\t\tinsideEscape = true;\n\t\t\tconst code = /\\d[^m]*/.exec(str.slice(i, i + 18));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t} else if (insideEscape && x === 'm') {\n\t\t\tinsideEscape = false;\n\t\t\tleftEscape = true;\n\t\t}\n\n\t\tif (!insideEscape && !leftEscape) {\n\t\t\t++visible;\n\t\t}\n\n\t\tif (!astralRegex({exact: true}).test(x) && isFullwidthCodePoint(x.codePointAt())) {\n\t\t\t++visible;\n\t\t}\n\n\t\tif (visible > begin && visible <= end) {\n\t\t\toutput += x;\n\t\t} else if (visible === begin && !insideEscape && escapeCode !== null && escapeCode !== END_CODE) {\n\t\t\toutput += wrapAnsi(escapeCode);\n\t\t} else if (visible >= end) {\n\t\t\tif (escapeCode !== null) {\n\t\t\t\toutput += wrapAnsi(ansiStyles.codes.get(parseInt(escapeCode, 10)) || END_CODE);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"script"}